<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ulawify â€“ WAV to Teensy .h/.cpp</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 720px;
      margin: 40px auto;
      padding: 20px;
      text-align: center;
    }
    canvas {
      width: 100%;
      height: 100px;
      border: 1px solid #ccc;
      cursor: crosshair;
    }
    .controls {
      margin: 20px 0;
      text-align: left;
    }
    label {
      display: inline-block;
      width: 100px;
    }
    #info {
      margin-top: 10px;
      font-size: 0.9em;
      color: #444;
    }
  </style>
</head>
<body>
  <h1>ulawify</h1>
  <p>Convert a WAV file to Teensy-compatible Âµ-law encoded <code>.h</code> and <code>.cpp</code></p>
  <input type="file" accept=".wav" id="fileInput"><br>

  <div class="controls">
    <label for="gain">Gain:</label>
    <input type="range" min="1" max="5" value="1" step="0.1" id="gain">
    <span id="gainVal">1.0</span><br><br>

    <label for="clipType">Clipping:</label>
<select id="clipType">
  <option value="soft">Soft (tanh)</option>
  <option value="hard">Hard (clip)</option>
</select><br><br>
<canvas id="waveform" width="700" height="100"></canvas>
    <div id="info"></div><br>

    <button onclick="previewAudio()">â–¶ Preview Trimmed Audio</button>
    <button onclick="processFile()">ðŸ“‚ Convert & Download</button>
    <p id="status"></p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    let audioBuffer, monoData = [], sampleRate = 44100;
    let startSample = 0, endSample = 0;
    let fileName = "sample";
    let selecting = false, selectStartX = 0, selectEndX = 0;
    const gainSlider = document.getElementById('gain');
    const gainVal = document.getElementById('gainVal');
    const canvas = document.getElementById('waveform');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const info = document.getElementById('info');
    const previewCtx = new (window.AudioContext || window.webkitAudioContext)();

    gainSlider.oninput = () => {
      gainVal.textContent = gainSlider.value;
  drawWaveform();
      drawWaveform();
    };

    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      fileName = file.name.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9]/g, '');
      const arrayBuffer = await file.arrayBuffer();
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let decoded = await ctx.decodeAudioData(arrayBuffer);

      if (decoded.sampleRate !== 44100) {
        const length = Math.floor(decoded.duration * 44100);
        const offline = new OfflineAudioContext(1, length, 44100);
        const src = offline.createBufferSource();
        src.buffer = decoded;
        src.connect(offline.destination);
        src.start();
        decoded = await offline.startRendering();
      }

      audioBuffer = decoded;
      const L = decoded.getChannelData(0);
      const R = decoded.numberOfChannels > 1 ? decoded.getChannelData(1) : L;
      const len = decoded.length;
      monoData = new Float32Array(len);
      for (let i = 0; i < len; i++) monoData[i] = (L[i] + R[i]) * 0.5;

      startSample = 0;
      endSample = len;
      drawWaveform();
    });

    function drawWaveform() {
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#888';
      const gain = parseFloat(gainSlider.value);
      const step = Math.floor(monoData.length / width);
      for (let x = 0; x < width; x++) {
        const i = x * step;
        const clipType = document.getElementById('clipType').value;
        const raw = (monoData[i] || 0) * gain;
        const v = (clipType === 'hard') ? Math.max(-1, Math.min(1, raw)) : Math.tanh(raw);
        const y = (1 - v) * height / 2;
        ctx.fillRect(x, y, 1, 1);
      }
      if (startSample !== endSample) {
        ctx.fillStyle = 'rgba(255,0,0,0.2)';
        const sx = (startSample / monoData.length) * width;
        const ex = (endSample / monoData.length) * width;
        ctx.fillRect(Math.min(sx, ex), 0, Math.abs(ex - sx), height);
      }

      const durationMs = ((endSample - startSample) / 44100 * 1000).toFixed(1);
      const byteSize = Math.ceil((endSample - startSample) / 4) * 4;
      const timeStart = (startSample / 44100).toFixed(2);
      const timeEnd = (endSample / 44100).toFixed(2);
      info.textContent = `Selection: ${durationMs} ms â€¢ ${byteSize} bytes (Âµ-law) â€¢ Start: ${timeStart}s â€¢ End: ${timeEnd}s`;
    }

    canvas.addEventListener('mousedown', (e) => {
      selecting = true;
      selectStartX = e.offsetX;
      selectEndX = e.offsetX;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (selecting) {
        selectEndX = e.offsetX;
        updateSelection();
      }
    });

    canvas.addEventListener('mouseup', () => {
      selecting = false;
    });

    function updateSelection() {
      const width = canvas.width;
      const startX = Math.min(selectStartX, selectEndX);
      const endX = Math.max(selectStartX, selectEndX);
      startSample = Math.floor((startX / width) * monoData.length);
      endSample = Math.floor((endX / width) * monoData.length);
      drawWaveform();
    }

    function linearToUlaw(sample) {
      const BIAS = 0x84;
      const CLIP = 32635;
      let sign = (sample >> 8) & 0x80;
      if (sign) sample = -sample;
      if (sample > CLIP) sample = CLIP;
      sample += BIAS;
      let exponent = 7;
      for (let expMask = 0x4000; (sample & expMask) === 0 && exponent > 0; expMask >>= 1)
        exponent--;
      let mantissa = (sample >> (exponent + 3)) & 0x0F;
      return ~(sign | (exponent << 4) | mantissa) & 0xFF;
    }

    function previewAudio() {
      const gain = parseFloat(gainSlider.value);
      const length = endSample - startSample;
      const clipped = new Float32Array(length);
      for (let i = 0; i < length; i++) {
        clipped[i] = Math.tanh(monoData[startSample + i] * gain);
      }
      const buf = previewCtx.createBuffer(1, length, 44100);
      buf.copyToChannel(clipped, 0);
      const src = previewCtx.createBufferSource();
      src.buffer = buf;
      src.connect(previewCtx.destination);
      src.start();
    }

    async function processFile() {
      const gain = parseFloat(gainSlider.value);
      const length = endSample - startSample;
      const trimmed = new Float32Array(length);
      for (let i = 0; i < length; i++) {
        trimmed[i] = Math.tanh(monoData[startSample + i] * gain);
      }

      const ulaw = new Uint8Array(length);
      for (let i = 0; i < length; i++) {
        const pcm = Math.floor(trimmed[i] * 32767);
        ulaw[i] = linearToUlaw(pcm);
      }

      const packed = [];
      for (let i = 0; i < ulaw.length; i += 4) {
        let val = 0;
        for (let j = 0; j < 4; j++) {
          val |= (ulaw[i + j] || 0) << (8 * (3 - j));
        }
        packed.push(val >>> 0);
      }

      const header = `// Audio data converted from WAV file by ulawify\n` +
        `extern const unsigned int ${fileName}[${packed.length}];\n`;

      let cpp = `// Audio data converted from WAV file by ulawify\n`;
      cpp += `#include \"${fileName}.h\"\n#include <Arduino.h>\n`;
      cpp += `// Converted from input.wav, using 44100 Hz, u-law encoding\nPROGMEM\n`;
      cpp += `const unsigned int ${fileName}[${packed.length}] = {\n`;
      for (let i = 0; i < packed.length; i++) {
        if (i % 8 === 0) cpp += '  ';
        cpp += `0x${packed[i].toString(16).padStart(8, '0')}, `;
        if ((i + 1) % 8 === 0) cpp += '\n';
      }
      cpp += '};\n';

      const zip = new JSZip();
      zip.file(`${fileName}.h`, header);
      zip.file(`${fileName}.cpp`, cpp);
      const blob = await zip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${fileName}_ulaw.zip`;
      a.click();
      status.textContent = 'Done!';
    }
  </script>
</body>
</html>
